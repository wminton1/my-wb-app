<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Whiteboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); height: 100vh; overflow: hidden; }
        .app-container { display: grid; grid-template-rows: auto 1fr auto; grid-template-columns: 300px 1fr 300px; grid-template-areas: "left-panel toolbar right-panel" "left-panel canvas right-panel" "left-panel status right-panel"; height: 100vh; gap: 10px; padding: 10px; visibility: hidden; opacity: 0; transition: opacity 0.3s ease; }
        .app-container.active { visibility: visible; opacity: 1; }
        .login-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); display: flex; justify-content: center; align-items: center; z-index: 2000; }
        .login-form { background: white; padding: 2.5rem; border-radius: 20px; box-shadow: 0 30px 60px rgba(0, 0, 0, 0.3); text-align: center; min-width: 450px; position: relative; z-index: 2001; }
        .login-form h2 { margin-bottom: 1rem; color: #333; font-size: 2rem; font-weight: 700; }
        .login-form .subtitle { color: #666; margin-bottom: 2rem; font-size: 1.1rem; }
        .role-selector { display: flex; gap: 1.5rem; margin: 2rem 0; justify-content: center; }
        .role-option { flex: 1; padding: 2rem 1rem; border: 3px solid #e0e0e0; border-radius: 15px; cursor: pointer; transition: all 0.3s ease; text-align: center; background: #fafafa; }
        .role-option.selected { border-color: #4285f4; background: linear-gradient(135deg, #f8f9ff, #e3f2fd); transform: translateY(-5px); box-shadow: 0 15px 30px rgba(66, 133, 244, 0.3); }
        .role-icon { font-size: 3rem; margin-bottom: 1rem; }
        .role-title { font-size: 1.3rem; font-weight: 600; margin-bottom: 0.5rem; color: #333; }
        .role-description { font-size: 0.9rem; color: #666; line-height: 1.4; }
        .login-form input { width: 100%; padding: 18px; margin: 0.8rem 0; border: 2px solid #e0e0e0; border-radius: 12px; font-size: 16px; transition: all 0.3s; background: #fafafa; }
        .login-form input:focus { border-color: #4285f4; outline: none; background: white; box-shadow: 0 0 0 3px rgba(66, 133, 244, 0.1); }
        .login-form button { width: 100%; padding: 18px; background: linear-gradient(135deg, #4285f4, #34a853); color: white; border: none; border-radius: 12px; font-size: 18px; font-weight: 600; cursor: pointer; margin-top: 1.5rem; transition: all 0.3s; }
        .lobby-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: none; justify-content: center; align-items: center; z-index: 1999; }
        .lobby-container { background: white; border-radius: 20px; padding: 2rem; width: 90%; max-width: 800px; max-height: 80vh; overflow-y: auto; box-shadow: 0 30px 60px rgba(0, 0, 0, 0.3); }
        .lobby-header { text-align: center; margin-bottom: 2rem; padding-bottom: 1rem; border-bottom: 2px solid #e0e0e0; }
        .lobby-title { font-size: 2rem; font-weight: 700; color: #333; margin-bottom: 0.5rem; }
        .room-code { font-size: 1.5rem; color: #4285f4; font-weight: 600; background: #f0f4ff; padding: 0.5rem 1rem; border-radius: 8px; display: inline-block; margin: 0.5rem 0; }
        .participants-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem; margin-top: 1rem; }
        .participant-card { background: #f8f9fa; border-radius: 12px; padding: 1rem; text-align: center; border: 2px solid transparent; }
        .participant-card.host { background: linear-gradient(135deg, #fff3e0, #ffe0b2); border-color: #ff9800; }
        .lobby-controls { display: flex; gap: 1rem; justify-content: center; margin-top: 2rem; padding-top: 1rem; border-top: 2px solid #e0e0e0; }
        .lobby-btn { padding: 1rem 2rem; border: none; border-radius: 12px; font-size: 1.1rem; font-weight: 600; cursor: pointer; transition: all 0.3s; }
        .lobby-btn.primary { background: linear-gradient(135deg, #4285f4, #34a853); color: white; }
        .toolbar { grid-area: toolbar; background: white; border-radius: 12px; padding: 1rem; display: flex; align-items: center; gap: 1rem; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); flex-wrap: wrap; }
        .tool-group { display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8f9fa; border-radius: 8px; }
        .tool-btn { padding: 8px 12px; border: none; border-radius: 6px; cursor: pointer; background: transparent; transition: all 0.2s; font-size: 14px; }
        .tool-btn:hover, .tool-btn.active { background: #4285f4; color: white; transform: translateY(-1px); }
        .canvas-area { grid-area: canvas; background: white; border-radius: 15px; box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1); overflow: hidden; position: relative; border: 3px solid #e0e0e0; }
        #whiteboard { width: 100%; height: 100%; display: block; cursor: crosshair; }
        .left-panel, .right-panel { background: white; border-radius: 12px; padding: 1rem; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); overflow-y: auto; }
        .left-panel { grid-area: left-panel; }
        .right-panel { grid-area: right-panel; display: flex; flex-direction: column; gap: 1rem; }
        .panel-section { background: #f8f9fa; border-radius: 8px; padding: 1rem; }
        .status-bar { grid-area: status; background: white; border-radius: 8px; padding: 0.7rem 1rem; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); font-size: 14px; }
        .text-input-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 3; }
        .text-input { position: absolute; background: transparent; border: 2px dashed #4285f4; outline: none; font-family: Arial, sans-serif; color: #333; padding: 4px; min-width: 100px; min-height: 30px; pointer-events: all; resize: both; overflow: hidden; }
        @media (max-width: 900px) { .app-container { grid-template-rows: auto auto 1fr auto; grid-template-columns: 1fr 1fr; grid-template-areas: "toolbar toolbar" "left-panel right-panel" "canvas canvas" "status status"; } .left-panel, .right-panel { max-height: 200px; } }
    </style>
</head>
<body>
    <div class="app-container" id="mainApp">
        <div class="toolbar">
            <div class="tool-group">
                <button type="button" class="tool-btn active" id="penTool" onclick="setTool('pen')">‚úèÔ∏è Pen</button>
                <button type="button" class="tool-btn" id="eraserTool" onclick="setTool('eraser')">üßΩ Eraser</button>
                <button type="button" class="tool-btn" id="textTool" onclick="setTool('text')">üìù Text</button>
                <button type="button" class="tool-btn" onclick="clearCanvas()">üóëÔ∏è Clear</button>
            </div>
            <div class="tool-group">
                <input type="color" id="colorPicker" value="#000000">
                <input type="range" id="sizeSlider" min="2" max="50" value="5">
                <span id="sizeDisplay">5px</span>
            </div>
        </div>
        <div class="canvas-area">
            <canvas id="whiteboard"></canvas>
            <div class="text-input-overlay" id="textInputOverlay"></div>
        </div>
        <div class="left-panel">
            <div class="panel-section">
                <h3>üìÅ Files</h3>
                <input type="file" id="fileInput" accept="image/*,.pdf,.ppt,.pptx" onchange="handleFileUpload(event)" style="width: 100%; margin-bottom: 1rem;">
                <div id="fileList" style="margin-bottom: 1rem;">
                    <div style="color: #666; font-size: 14px;">No files uploaded</div>
                </div>
                <button type="button" onclick="clearBackground()" style="width: 100%; padding: 8px; background: #f44336; color: white; border: none; border-radius: 6px; margin-bottom: 1rem;">Clear Background</button>
                <div id="slideControls" style="display: none;">
                    <div style="display: flex; gap: 0.5rem; align-items: center; margin-bottom: 1rem;">
                        <button type="button" onclick="previousSlide()" style="padding: 8px 12px; background: #4285f4; color: white; border: none; border-radius: 6px;">‚Üê Prev</button>
                        <span id="slideCounter" style="font-size: 14px; font-weight: 600;">1 / 1</span>
                        <button type="button" onclick="nextSlide()" style="padding: 8px 12px; background: #4285f4; color: white; border: radius: 6px;">Next ‚Üí</button>
                    </div>
                    <button type="button" onclick="clearSlideDrawings()" style="width: 100%; padding: 8px; background: #ff9800; color: white; border: none; border-radius: 6px;">Clear Slide Drawings</button>
                </div>
                
                <!-- Host Controls for Participant Permissions -->
                <div id="hostPermissionControls" style="display: none; margin-top: 1rem; padding: 1rem; background: #fff3e0; border-radius: 8px; border-left: 4px solid #ff9800;">
                    <h4 style="margin-bottom: 1rem; color: #333;">üéØ Host Controls</h4>
                    <button type="button" id="toggleDrawingBtn" onclick="toggleParticipantDrawing()" style="width: 100%; padding: 8px; background: #4caf50; color: white; border: none; border-radius: 6px; margin-bottom: 0.5rem;">
                        üñäÔ∏è Drawing: Enabled
                    </button>
                    <button type="button" id="toggleChatBtn" onclick="toggleParticipantChat()" style="width: 100%; padding: 8px; background: #4caf50; color: white; border: none; border-radius: 6px;">
                        üí¨ Chat: Enabled
                    </button>
                </div>
            </div>
        </div>
        <div class="right-panel">
            <div class="panel-section">
                <h3>üë• Participants</h3>
                <div id="usersList"></div>
            </div>
            <div class="panel-section">
                <h3>üí¨ Chat</h3>
                <div id="chatMessages" style="height: 150px; overflow-y: auto; border: 1px solid #e0e0e0; border-radius: 8px; padding: 0.7rem; background: white; margin-bottom: 0.5rem;"></div>
                <div style="display: flex; gap: 0.5rem;">
                    <input type="text" id="chatInput" placeholder="Type message..." style="flex: 1; padding: 10px; border: 1px solid #e0e0e0; border-radius: 8px;">
                    <button type="button" onclick="sendMessage()" style="padding: 10px 15px; background: #4285f4; color: white; border: none; border-radius: 8px;">Send</button>
                </div>
            </div>
        </div>
        <div class="status-bar">
            <div><strong>Room:</strong> <span id="currentRoom">-</span></div>
            <div id="participantCount">0 participants</div>
        </div>
    </div>

    <div class="login-screen" id="loginScreen">
        <div class="login-form">
            <h2>Collaborative Whiteboard</h2>
            <p class="subtitle">Choose how you want to participate</p>
            <div class="role-selector">
                <div class="role-option" id="hostRole" onclick="selectRole('host')">
                    <div class="role-icon">üéØ</div>
                    <div class="role-title">Create Room</div>
                    <div class="role-description">Start a new session</div>
                </div>
                <div class="role-option selected" id="participantRole" onclick="selectRole('participant')">
                    <div class="role-icon">üë•</div>
                    <div class="role-title">Join Room</div>
                    <div class="role-description">Enter existing room</div>
                </div>
            </div>
            <input type="text" id="usernameInput" placeholder="Your name" maxlength="25">
            <input type="text" id="roomIdInput" placeholder="Room code (leave empty to create)" maxlength="20">
            <button type="button" onclick="joinRoom()">Continue</button>
        </div>
    </div>

    <div class="lobby-screen" id="lobbyScreen">
        <div class="lobby-container">
            <div class="lobby-header">
                <h2 class="lobby-title">Room Lobby</h2>
                <div class="room-code" id="lobbyRoomCode">ABC123</div>
            </div>
            <div class="participants-grid" id="lobbyParticipants">
                <!-- Participants will be populated here -->
            </div>
            <div class="lobby-controls">
                <button type="button" class="lobby-btn" onclick="leaveLobby()">Leave</button>
                <button type="button" class="lobby-btn primary" id="startSessionBtn" onclick="startSession()" style="display: none;">Start Session</button>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        
        // Simplified universal coordinates
        const VIRTUAL_WIDTH = 1920;
        const VIRTUAL_HEIGHT = 1080;
        let scale = 1, offsetX = 0, offsetY = 0;
        
        // Enhanced state for permissions and debugging
        let currentTool = 'pen', currentColor = '#000000', currentSize = 5;
        let currentRoom = '', username = '', userRole = 'participant', isHost = false;
        let sessionStarted = false, isDrawing = false, lastPoint = null;
        let backgroundImage = null, slides = [], currentSlideIndex = 0;
        let slideDrawings = new Map();
        let canDraw = true, canChat = true; // Participant permissions
        
        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            const scaleX = rect.width / VIRTUAL_WIDTH;
            const scaleY = rect.height / VIRTUAL_HEIGHT;
            scale = Math.min(scaleX, scaleY);
            
            offsetX = (rect.width - VIRTUAL_WIDTH * scale) / 2;
            offsetY = (rect.height - VIRTUAL_HEIGHT * scale) / 2;
            
            console.log(`Canvas: ${rect.width}x${rect.height}, Scale: ${scale.toFixed(3)}`);
        }
        
        function getVirtualCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || e.touches?.[0]?.clientX || 0;
            const clientY = e.clientY || e.touches?.[0]?.clientY || 0;
            
            const x = Math.max(0, Math.min(VIRTUAL_WIDTH, (clientX - rect.left - offsetX) / scale));
            const y = Math.max(0, Math.min(VIRTUAL_HEIGHT, (clientY - rect.top - offsetY) / scale));
            
            return { x, y };
        }
        
        function drawLocal(coords, type) {
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);
            ctx.lineWidth = currentSize;
            ctx.lineCap = 'round';
            ctx.strokeStyle = currentColor;
            
            if (currentTool === 'eraser') ctx.globalCompositeOperation = 'destination-out';
            
            if (type === 'start') {
                ctx.beginPath();
                ctx.moveTo(coords.x, coords.y);
            } else if (lastPoint) {
                ctx.beginPath();
                ctx.moveTo(lastPoint.x, lastPoint.y);
                ctx.lineTo(coords.x, coords.y);
                ctx.stroke();
            }
            ctx.restore();
        }
        
        function drawRemote(data) {
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);
            ctx.lineWidth = data.size;
            ctx.lineCap = 'round';
            ctx.strokeStyle = data.color;
            
            if (data.tool === 'eraser') ctx.globalCompositeOperation = 'destination-out';
            
            if (data.type === 'draw' && data.lastX !== undefined) {
                ctx.beginPath();
                ctx.moveTo(data.lastX, data.lastY);
                ctx.lineTo(data.x, data.y);
                ctx.stroke();
            }
            ctx.restore();
        }
        
        function startDrawing(e) {
            e.preventDefault();
            if (!sessionStarted) return;
            
            // Check permissions for participants
            if (!isHost && !canDraw) {
                addChatMessage('System', 'Drawing is disabled by the host');
                return;
            }
            
            // Handle text tool
            if (currentTool === 'text') {
                addTextBox(e);
                return;
            }
            
            isDrawing = true;
            const coords = getVirtualCoords(e);
            lastPoint = coords;
            
            drawLocal(coords, 'start');
            socket.emit('drawing', { x: coords.x, y: coords.y, color: currentColor, size: currentSize, tool: currentTool, type: 'start', slideIndex: currentSlideIndex });
        }
        
        function sendMessage() {
            // Check chat permissions for participants
            if (!isHost && !canChat) {
                addChatMessage('System', 'Chat is disabled by the host');
                return;
            }
            
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            if (message) {
                socket.emit('chat-message', message);
                input.value = '';
            }
        }
        
        function addTextBox(e) {
            const coords = getVirtualCoords(e);
            const canvasCoords = {
                x: coords.x * scale + offsetX,
                y: coords.y * scale + offsetY
            };
            
            const textInput = document.createElement('textarea');
            textInput.style.cssText = `
                position: absolute;
                left: ${canvasCoords.x}px;
                top: ${canvasCoords.y}px;
                background: transparent;
                border: 2px dashed #4285f4;
                outline: none;
                font-family: Arial, sans-serif;
                font-size: ${Math.max(12, currentSize)}px;
                color: ${currentColor};
                padding: 4px;
                min-width: 100px;
                min-height: 30px;
                resize: both;
                z-index: 1000;
            `;
            textInput.placeholder = 'Type text here...';
            
            const finishText = () => {
                const text = textInput.value.trim();
                if (text) {
                    // Draw text on canvas
                    ctx.save();
                    ctx.translate(offsetX, offsetY);
                    ctx.scale(scale, scale);
                    ctx.font = `${Math.max(12, currentSize)}px Arial`;
                    ctx.fillStyle = currentColor;
                    ctx.textBaseline = 'top';
                    ctx.fillText(text, coords.x, coords.y);
                    ctx.restore();
                    
                    // Broadcast text to other users
                    socket.emit('text-added', {
                        x: coords.x,
                        y: coords.y,
                        text: text,
                        color: currentColor,
                        size: Math.max(12, currentSize),
                        slideIndex: currentSlideIndex
                    });
                }
                textInput.remove();
            };
            
            textInput.addEventListener('blur', finishText);
            textInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') finishText();
                e.stopPropagation();
            });
            
            document.getElementById('textInputOverlay').appendChild(textInput);
            setTimeout(() => textInput.focus(), 10);
        }
        
        function draw(e) {
            e.preventDefault();
            if (!isDrawing || !sessionStarted) return;
            
            const coords = getVirtualCoords(e);
            drawLocal(coords, 'draw');
            
            // Store drawing for current slide
            const slideKey = `slide_${currentSlideIndex}`;
            if (!slideDrawings.has(slideKey)) {
                slideDrawings.set(slideKey, []);
            }
            
            // Add to current stroke or create new one
            const currentDrawings = slideDrawings.get(slideKey);
            if (currentDrawings.length === 0 || !currentDrawings[currentDrawings.length - 1].path) {
                currentDrawings.push({
                    tool: currentTool,
                    color: currentColor,
                    size: currentSize,
                    path: [lastPoint, coords]
                });
            } else {
                currentDrawings[currentDrawings.length - 1].path.push(coords);
            }
            
            socket.emit('drawing', { 
                x: coords.x, y: coords.y, 
                lastX: lastPoint?.x, lastY: lastPoint?.y,
                color: currentColor, size: currentSize, tool: currentTool, type: 'draw',
                slideIndex: currentSlideIndex
            });
            lastPoint = coords;
        }
        
        function stopDrawing(e) {
            if (!isDrawing) return;
            e.preventDefault();
            isDrawing = false;
            lastPoint = null;
            socket.emit('drawing', { type: 'stop' });
        }
        
        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tool + 'Tool').classList.add('active');
        }
        
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            socket.emit('clear-canvas');
        }
        
        function selectRole(role) {
            userRole = role;
            isHost = (role === 'host');
            document.querySelectorAll('.role-option').forEach(opt => opt.classList.remove('selected'));
            document.getElementById(role + 'Role').classList.add('selected');
        }
        
        function joinRoom() {
            username = document.getElementById('usernameInput').value.trim();
            if (!username) { alert('Enter your name'); return; }
            
            const roomInput = document.getElementById('roomIdInput').value.trim();
            currentRoom = isHost ? (roomInput || Math.random().toString(36).substring(2, 8).toUpperCase()) : roomInput.toUpperCase();
            
            if (!isHost && !currentRoom) { alert('Enter room code'); return; }
            
            // Always try to join room, regardless of state
            socket.emit(isHost ? 'create-room' : 'join-room', { 
                roomId: currentRoom, 
                username, 
                role: userRole 
            });
            
            console.log(`Attempting to ${isHost ? 'create' : 'join'} room:`, currentRoom);
        }
        
        function showLobby() {
            document.getElementById('loginScreen').style.display = 'none';
            document.getElementById('lobbyScreen').style.display = 'flex';
            document.getElementById('lobbyRoomCode').textContent = currentRoom;
            if (isHost) document.getElementById('startSessionBtn').style.display = 'block';
        }
        
        function updateLobbyParticipants(participants) {
            const container = document.getElementById('lobbyParticipants');
            container.innerHTML = participants.map(participant => {
                const roleIcon = participant.role === 'host' ? 'üéØ' : 'üë•';
                return `
                    <div style="
                        background: ${participant.role === 'host' ? 'linear-gradient(135deg, #fff3e0, #ffe0b2)' : '#f8f9fa'};
                        border-radius: 12px;
                        padding: 1rem;
                        text-align: center;
                        border: 2px solid ${participant.role === 'host' ? '#ff9800' : 'transparent'};
                    ">
                        <div style="font-size: 2rem; margin-bottom: 0.5rem;">${roleIcon}</div>
                        <div style="font-weight: 600; margin-bottom: 0.25rem;">${participant.username}</div>
                        <div style="font-size: 0.8rem; color: #666; text-transform: uppercase;">${participant.role}</div>
                    </div>
                `;
            }).join('');
        }
        
        function startSession() {
            if (!isHost) return;
            socket.emit('start-session');
        }
        
        function leaveLobby() {
            socket.emit('leave-room');
            window.location.reload();
        }
        
        function enterWhiteboard() {
            document.getElementById('lobbyScreen').style.display = 'none';
            const mainApp = document.getElementById('mainApp');
            mainApp.style.display = 'grid';
            mainApp.classList.add('active');
            document.getElementById('currentRoom').textContent = currentRoom;
            
            // Show host controls if user is host
            if (isHost) {
                document.getElementById('hostPermissionControls').style.display = 'block';
            }
            
            resizeCanvas();
            sessionStarted = true;
            
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('touchstart', startDrawing, { passive: false });
            canvas.addEventListener('touchmove', draw, { passive: false });
            canvas.addEventListener('touchend', stopDrawing, { passive: false });
        }
        
        function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            if (message) {
                socket.emit('chat-message', message);
                input.value = '';
            }
        }
        
        function addChatMessage(sender, message) {
            const chatMessages = document.getElementById('chatMessages');
            const div = document.createElement('div');
            div.innerHTML = `<strong>${sender}:</strong> ${message}`;
            chatMessages.appendChild(div);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        function updateParticipants(participants) {
            document.getElementById('participantCount').textContent = `${participants.length} participants`;
            const usersList = document.getElementById('usersList');
            usersList.innerHTML = participants.map(p => `<div>${p.role === 'host' ? 'üéØ' : 'üë•'} ${p.username}</div>`).join('');
        }
        
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            console.log('File selected:', file.name, file.type);
            
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = `<div style="color: #4285f4; font-weight: 600;">üìÅ ${file.name} (uploading...)</div>`;
            
            // Immediate notification
            socket.emit('file-upload-started', {
                filename: file.name,
                type: file.type,
                username: username
            });
            
            if (file.type.startsWith('image/')) {
                handleImageFile(file);
            } else if (file.name.endsWith('.pdf') || file.name.endsWith('.ppt') || file.name.endsWith('.pptx')) {
                handlePresentationFile(file);
            }
        }
        
        function handleImageFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                console.log('Image loaded, setting as background');
                
                slides = [e.target.result];
                currentSlideIndex = 0;
                loadCurrentSlide();
                
                // Update file list
                const fileList = document.getElementById('fileList');
                fileList.innerHTML = `<div style="color: #4285f4; font-weight: 600;">üìÅ ${file.name} (active)</div>`;
                
                // Broadcast to ALL users including self
                socket.emit('background-image-set', {
                    imageData: e.target.result,
                    filename: file.name,
                    username: username
                });
                
                console.log('Background image broadcast sent');
            };
            reader.readAsDataURL(file);
        }
        
        function clearBackground() {
            backgroundImage = null;
            slides = [];
            currentSlideIndex = 0;
            document.getElementById('slideControls').style.display = 'none';
            document.getElementById('fileList').innerHTML = '<div style="color: #666; font-size: 14px;">No files uploaded</div>';
            
            redrawCanvas(); // This will clear the background
            
            socket.emit('background-cleared', { username: username });
            addChatMessage('System', 'Background cleared');
        }
        
        function toggleParticipantDrawing() {
            if (!isHost) return;
            
            socket.emit('toggle-participant-drawing');
        }
        
        function toggleParticipantChat() {
            if (!isHost) return;
            
            socket.emit('toggle-participant-chat');
        }
        
        function updatePermissionButtons(settings) {
            if (!isHost) return;
            
            const drawBtn = document.getElementById('toggleDrawingBtn');
            const chatBtn = document.getElementById('toggleChatBtn');
            
            if (settings.participantsCanDraw) {
                drawBtn.textContent = 'üö´ Drawing: Enabled (Click to Disable)';
                drawBtn.style.background = '#4caf50';
            } else {
                drawBtn.textContent = 'üñäÔ∏è Drawing: Disabled (Click to Enable)';
                drawBtn.style.background = '#f44336';
            }
            
            if (settings.participantsCanChat) {
                chatBtn.textContent = 'üö´ Chat: Enabled (Click to Disable)';
                chatBtn.style.background = '#4caf50';
            } else {
                chatBtn.textContent = 'üí¨ Chat: Disabled (Click to Enable)';
                chatBtn.style.background = '#f44336';
            }
        }
        
        function handleImageFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                slides = [e.target.result];
                currentSlideIndex = 0;
                loadCurrentSlide();
                
                // Broadcast to other users IMMEDIATELY
                socket.emit('file-shared', {
                    type: 'image',
                    data: e.target.result,
                    filename: file.name,
                    username: username
                });
                
                console.log('Image file shared:', file.name);
            };
            reader.readAsDataURL(file);
        }
        
        function handlePresentationFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                // Create demo slides for presentation
                const demoSlides = [];
                for (let i = 1; i <= 5; i++) {
                    const canvas = document.createElement('canvas');
                    canvas.width = VIRTUAL_WIDTH;
                    canvas.height = VIRTUAL_HEIGHT;
                    const ctx = canvas.getContext('2d');
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#4285f4';
                    ctx.font = '48px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Slide ${i}`, canvas.width/2, canvas.height/2);
                    ctx.fillStyle = '#666';
                    ctx.font = '24px Arial';
                    ctx.fillText(file.name, canvas.width/2, canvas.height/2 + 60);
                    
                    demoSlides.push(canvas.toDataURL());
                }
                
                slides = demoSlides;
                currentSlideIndex = 0;
                slideDrawings.clear();
                
                document.getElementById('slideControls').style.display = 'block';
                updateSlideCounter();
                loadCurrentSlide();
                
                // Broadcast to other users IMMEDIATELY
                socket.emit('presentation-shared', {
                    slides: slides,
                    filename: file.name,
                    currentSlide: currentSlideIndex,
                    username: username
                });
                
                console.log('Presentation shared:', file.name);
            };
            reader.readAsDataURL(file);
        }
        
        function loadCurrentSlide() {
            if (slides.length === 0) return;
            
            const img = new Image();
            img.onload = function() {
                backgroundImage = img;
                redrawCanvas();
            };
            img.src = slides[currentSlideIndex];
        }
        
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background/slide
            if (backgroundImage) {
                ctx.save();
                ctx.translate(offsetX, offsetY);
                ctx.scale(scale, scale);
                ctx.drawImage(backgroundImage, 0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);
                ctx.restore();
            }
            
            // Draw slide-specific drawings
            const slideKey = `slide_${currentSlideIndex}`;
            const drawings = slideDrawings.get(slideKey) || [];
            drawings.forEach(drawing => {
                ctx.save();
                ctx.translate(offsetX, offsetY);
                ctx.scale(scale, scale);
                ctx.lineWidth = drawing.size;
                ctx.lineCap = 'round';
                ctx.strokeStyle = drawing.color;
                if (drawing.tool === 'eraser') ctx.globalCompositeOperation = 'destination-out';
                
                if (drawing.path && drawing.path.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(drawing.path[0].x, drawing.path[0].y);
                    for (let i = 1; i < drawing.path.length; i++) {
                        ctx.lineTo(drawing.path[i].x, drawing.path[i].y);
                    }
                    ctx.stroke();
                }
                ctx.restore();
            });
        }
        
        function nextSlide() {
            if (currentSlideIndex < slides.length - 1) {
                currentSlideIndex++;
                updateSlideCounter();
                loadCurrentSlide();
                socket.emit('slide-changed', { slideIndex: currentSlideIndex });
            }
        }
        
        function previousSlide() {
            if (currentSlideIndex > 0) {
                currentSlideIndex--;
                updateSlideCounter();
                loadCurrentSlide();
                socket.emit('slide-changed', { slideIndex: currentSlideIndex });
            }
        }
        
        function updateSlideCounter() {
            document.getElementById('slideCounter').textContent = `${currentSlideIndex + 1} / ${slides.length}`;
        }
        
        function clearSlideDrawings() {
            const slideKey = `slide_${currentSlideIndex}`;
            slideDrawings.delete(slideKey);
            redrawCanvas();
            socket.emit('slide-drawings-cleared', { slideIndex: currentSlideIndex });
        }
        
        // Socket events
        socket.on('room-created', (data) => { 
            console.log('Room created successfully');
            showLobby(); 
            updateLobbyParticipants(data.participants); 
        });
        
        socket.on('room-joined', (data) => { 
            console.log('Room joined successfully');
            if (data.roomState === 'active') {
                // Room is already active, skip lobby and go straight to whiteboard
                enterWhiteboard();
                updateParticipants(data.participants);
                
                // Load existing room content
                if (data.slides) {
                    slides = data.slides;
                    currentSlideIndex = data.currentSlide || 0;
                    if (slides.length > 1) {
                        document.getElementById('slideControls').style.display = 'block';
                        updateSlideCounter();
                    }
                    loadCurrentSlide();
                }
            } else {
                // Room is in lobby, show lobby
                showLobby(); 
                updateLobbyParticipants(data.participants);
            }
        });
        
        socket.on('lobby-updated', (data) => updateLobbyParticipants(data.participants));
        socket.on('session-starting', () => setTimeout(enterWhiteboard, 1000));
        socket.on('session-started', (data) => { 
            enterWhiteboard(); 
            if (data.participants) updateParticipants(data.participants); 
        });
        
        socket.on('drawing', (data) => {
            // Only draw if it's for the current slide
            if (data.slideIndex === undefined || data.slideIndex === currentSlideIndex) {
                drawRemote(data);
            }
        });
        
        socket.on('clear-canvas', () => {
            const slideKey = `slide_${currentSlideIndex}`;
            slideDrawings.delete(slideKey);
            redrawCanvas();
        });
        
        socket.on('chat-message', (data) => addChatMessage(data.username, data.message));
        socket.on('room-not-found', () => alert('Room not found'));
        
        // Enhanced file sharing events with better debugging
        socket.on('file-upload-started', (data) => {
            console.log('Someone started uploading:', data);
            addChatMessage('System', `üìÅ ${data.username} is uploading: ${data.filename}`);
        });
        
        socket.on('background-image-set', (data) => {
            console.log('Background image received from:', data.username);
            
            const img = new Image();
            img.onload = function() {
                backgroundImage = img;
                slides = [data.imageData];
                currentSlideIndex = 0;
                loadCurrentSlide();
                
                const fileList = document.getElementById('fileList');
                fileList.innerHTML = `<div style="color: #4285f4; font-weight: 600;">üìÅ ${data.filename} (by ${data.username})</div>`;
                
                addChatMessage('System', `üìÅ ${data.username} set background: ${data.filename}`);
            };
            img.src = data.imageData;
        });
        
        socket.on('background-cleared', (data) => {
            backgroundImage = null;
            slides = [];
            currentSlideIndex = 0;
            document.getElementById('slideControls').style.display = 'none';
            document.getElementById('fileList').innerHTML = '<div style="color: #666; font-size: 14px;">No files uploaded</div>';
            redrawCanvas();
            addChatMessage('System', `üóëÔ∏è ${data.username} cleared the background`);
        });
        
        // Permission management events
        socket.on('permissions-updated', (data) => {
            console.log('Permissions updated:', data);
            
            if (!isHost) {
                canDraw = data.settings.participantsCanDraw;
                canChat = data.settings.participantsCanChat;
                
                // Update UI based on permissions
                const chatInput = document.getElementById('chatInput');
                chatInput.disabled = !canChat;
                chatInput.placeholder = canChat ? 'Type message...' : 'Chat disabled by host';
                
                if (!canDraw) {
                    addChatMessage('System', 'üö´ Drawing has been disabled');
                } else {
                    addChatMessage('System', 'üñäÔ∏è Drawing has been enabled');
                }
                
                if (!canChat) {
                    addChatMessage('System', 'üö´ Chat has been disabled');
                } else {
                    addChatMessage('System', 'üí¨ Chat has been enabled');
                }
            } else {
                // Update host control buttons
                updatePermissionButtons(data.settings);
            }
        });
        
        socket.on('slide-changed', (data) => {
            currentSlideIndex = data.slideIndex;
            updateSlideCounter();
            loadCurrentSlide();
        });
        
        socket.on('slide-drawings-cleared', (data) => {
            if (data.slideIndex === currentSlideIndex) {
                const slideKey = `slide_${currentSlideIndex}`;
                slideDrawings.delete(slideKey);
                redrawCanvas();
            }
        });
        
        socket.on('text-added', (data) => {
            if (data.slideIndex === undefined || data.slideIndex === currentSlideIndex) {
                ctx.save();
                ctx.translate(offsetX, offsetY);
                ctx.scale(scale, scale);
                ctx.font = `${data.size}px Arial`;
                ctx.fillStyle = data.color;
                ctx.textBaseline = 'top';
                ctx.fillText(data.text, data.x, data.y);
                ctx.restore();
            }
        });
        
        // Tool controls
        document.getElementById('colorPicker').addEventListener('change', (e) => currentColor = e.target.value);
        document.getElementById('sizeSlider').addEventListener('input', (e) => {
            currentSize = e.target.value;
            document.getElementById('sizeDisplay').textContent = e.target.value + 'px';
        });
        document.getElementById('chatInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });
        window.addEventListener('resize', () => { if (sessionStarted) resizeCanvas(); });
        
        resizeCanvas();
    </script>
</body>
</html>
